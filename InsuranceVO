pragma solidity ^0.4.0;

contract MSInsuranceVO {
    struct Patient{
        bool premiumpaid;
        address patientaddress;
        uint premium;
        mapping(address=>uint) votinglist;
    }
    
    struct Hospital{
        address hospitaladdress;
        uint subspercentage;
        bool isregistered;
        bool isactive;

        bool isinvotestage;
        uint votecount1;
        uint votecount2;
        uint votestartdate;
        uint voteenddate;
        
        Offer hospitaloffer;
    }
    
    struct Offer{
        string hospitalname;
        address hospitaladdress;
        string offerdesc;
        string[] coveragedepts;
        uint[] prices;
        uint[] percentages;
    }
    
    struct Transaction{
        address hospitaladdress;
        address patientaddress;
        uint date;
        string department;
        
        uint price;
        uint coverage;
        uint patienttobepaid;
        
        bool ispatientpaid;
        uint hospitalamount;
        bool ishospitalpaid; 
        uint subscriptionamount;
        bool issubspaid;
        
        bool isactive;
    }

    uint public periodno ;
    uint public startperiod ; 
    uint public endperiod ;
    
    mapping (address => uint) paidpremium ;
    mapping (address => Patient) registeredpatients ;
    mapping (uint=>mapping(address => Patient)) historypatient;
    
    mapping (address => Hospital) registeredhospitals;
    mapping (uint=>mapping(address => Hospital)) historyhospital;
    
    mapping(address=>Offer) periodoffers;
    
    mapping(address=>Transaction) transactionbypatient;
    mapping(address=>Transaction) transactionbyhospital;
    mapping(uint=>mapping(address=>Transaction)) historytransbypatient;
    mapping(uint=>mapping(address=>Transaction)) historytransbyhospital;
    
    function MSInsuranceVO() { 
        periodno = 1; 
        startperiod = now;
        endperiod = startperiod + 365;
        paidpremium[msg.sender] = 1;
        
        registeredpatients[msg.sender].premiumpaid = true;
        registeredpatients[msg.sender].patientaddress = msg.sender;
        registeredpatients[msg.sender].premium = 1;
        
        registeredhospitals[msg.sender].hospitaladdress = msg.sender;
        registeredhospitals[msg.sender].subspercentage = 2;
        registeredhospitals[msg.sender].isregistered = true;
        registeredhospitals[msg.sender].isactive = false;
        registeredhospitals[msg.sender].isinvotestage = true;
        registeredhospitals[msg.sender].votecount1 = 0;
        registeredhospitals[msg.sender].votecount2 = 0;
        registeredhospitals[msg.sender].votestartdate = now;
        registeredhospitals[msg.sender].voteenddate = now + 365;
        
        registeredhospitals[0xe4e10dcf8011a091979313de6931992174ba2885].hospitaladdress = 0xe4e10dcf8011a091979313de6931992174ba2885;
        registeredhospitals[msg.sender].subspercentage = 2;
        registeredhospitals[msg.sender].isregistered = true;
        registeredhospitals[msg.sender].isactive = false;
        registeredhospitals[msg.sender].isinvotestage = true;
        registeredhospitals[msg.sender].votecount1 = 0;
        registeredhospitals[msg.sender].votecount2 = 0;
        registeredhospitals[msg.sender].votestartdate = now;
        registeredhospitals[msg.sender].voteenddate = now + 365;
    }
    
    //after login
    function CheckifPatientRegistered(address PatientAdd) constant returns (bool isregistered){
        if(registeredpatients[PatientAdd].premiumpaid){
            isregistered=true;
        }else{
            isregistered = false;
        }
        
    }
    
    function CheckifHospitalRegistered(address HospitalAdd) constant returns (bool isregistered){
        if(registeredhospitals[HospitalAdd].isregistered){
            isregistered = true;
        }else{
            isregistered = false;
        }
        
    }
    
    function CheckifPreimumPaid(address PatientAdd) constant returns (bool ispremiumpaid){
        ispremiumpaid=false;
        if(paidpremium[PatientAdd] != 0){
            ispremiumpaid=true;
        }
    }

    function CalculatePremium(address PatientAdd) constant returns(uint premiumamount){
        //to be filled, ins.
        premiumamount=500;
    }
    
    function CalculateSubscription(address HospitalAdd) constant returns(uint subspercentage){
        //to be filled, ins.
        subspercentage=2;
    }
    
    function PremiumPay(address PatientAdd, uint amount) public payable {
        paidpremium[PatientAdd] = amount;
    }
    
    function RegisterPerson(address PatientAdd, uint amount) returns(bool registerstatus) {
        registerstatus = false;
        if(!CheckifPatientRegistered(PatientAdd)){
            if(CheckifPreimumPaid(PatientAdd)){
                registeredpatients[PatientAdd].premiumpaid = true;
                registeredpatients[PatientAdd].patientaddress = PatientAdd;
                registeredpatients[PatientAdd].premium = amount;
                
                registerstatus = true;
            }
        }
    }
    
    function RegisterHospital(address HospitalAdd, uint percentage) returns (bool registerstatus) {
        registerstatus = false;
        if(!CheckifHospitalRegistered(HospitalAdd)){
            registeredhospitals[HospitalAdd].isregistered = true;
            registeredhospitals[HospitalAdd].hospitaladdress = HospitalAdd;
            registeredhospitals[HospitalAdd].subspercentage = percentage;
            registeredhospitals[HospitalAdd].isinvotestage = true;
            registeredhospitals[HospitalAdd].isactive = false;
            registeredhospitals[HospitalAdd].votecount1 = 0;
            registeredhospitals[HospitalAdd].votecount2 = 0;
            registeredhospitals[HospitalAdd].votestartdate = now;
            registeredhospitals[HospitalAdd].voteenddate = registeredhospitals[HospitalAdd].votestartdate + 7 days;
            
            registerstatus = true;
        }
    }
    
    function AddOffer(address HospitalAdd, string hospitalname, string hospitaldesc) returns (bool offerstatus)  {
        offerstatus = false;
         if(CheckifHospitalRegistered(HospitalAdd)){  
            registeredhospitals[HospitalAdd].hospitaloffer.hospitalname = hospitalname;
            registeredhospitals[HospitalAdd].hospitaloffer.hospitaladdress = HospitalAdd;
            registeredhospitals[HospitalAdd].hospitaloffer.offerdesc = hospitaldesc;
            
            periodoffers[HospitalAdd].hospitalname = hospitalname;
            periodoffers[HospitalAdd].hospitaladdress = HospitalAdd;
            periodoffers[HospitalAdd].offerdesc = hospitaldesc;
            
            offerstatus = true;
         }else{
             throw;
         }
    }
    
    function AddOfferCoverage(address HospitalAdd, string covdep, uint covprice, uint covperc) returns (bool coveragestatus) {
        coveragestatus = false;
        if(CheckifHospitalRegistered(HospitalAdd)){
            registeredhospitals[HospitalAdd].hospitaloffer.coveragedepts.push(covdep);
            registeredhospitals[HospitalAdd].hospitaloffer.prices.push(covprice);
            registeredhospitals[HospitalAdd].hospitaloffer.percentages.push(covperc);
            periodoffers[HospitalAdd].coveragedepts.push(covdep);
            periodoffers[HospitalAdd].prices.push(covprice);
            periodoffers[HospitalAdd].percentages.push(covperc);
            
            coveragestatus = true;
        }else
            throw;
    }
    
    function VoteTheHosptal(address VoterAdd, address HospitalAdd, uint vote) returns (bool votestatus){
        votestatus = false;
        if(CheckifPatientRegistered(VoterAdd) && CheckifHospitalRegistered(HospitalAdd) && registeredhospitals[HospitalAdd].isinvotestage){
            if(registeredhospitals[HospitalAdd].voteenddate >= now){
                if(registeredpatients[VoterAdd].votinglist[HospitalAdd] != 1 && registeredpatients[VoterAdd].votinglist[HospitalAdd] != 2 ){
                    registeredpatients[VoterAdd].votinglist[HospitalAdd] = vote;
                    if(vote == 1)  registeredhospitals[HospitalAdd].votecount1 += 1;
                    else if(vote == 2)  registeredhospitals[HospitalAdd].votecount2 += 1;
                    votestatus = true;
                }
                else{
                    throw;
                }
            }else{
                registeredhospitals[HospitalAdd].isinvotestage = false;
                if(registeredhospitals[HospitalAdd].votecount1 >= registeredhospitals[HospitalAdd].votecount2){
                    registeredhospitals[HospitalAdd].isactive = true;
                }else{
                    registeredhospitals[HospitalAdd].isactive = false;
                }
            }
        }else {
            throw;
        }
    }
    
    function GetOfferOfHospital (address HospitalAdd) constant returns(string offerdetails){
        Offer theOffer = registeredhospitals[HospitalAdd].hospitaloffer;
        offerdetails = strConcat(theOffer.hospitalname, theOffer.offerdesc);
        for(uint i = 0; i < theOffer.coveragedepts.length; i++){
            offerdetails = strConcat(offerdetails, theOffer.coveragedepts[i]);
        }
    }
    
    function GetTheVote (address PersonAdd, address HospitalAdd) constant returns(uint vote){
        vote = registeredpatients[PersonAdd].votinglist[HospitalAdd];
    }
    
    function GetTheVoteCount1 (address HospitalAdd) constant returns(uint votecount){
        votecount = registeredhospitals[HospitalAdd].votecount1;
    }
    
    function GetTheVoteCount2 (address HospitalAdd) constant returns(uint votecount){
        votecount = registeredhospitals[HospitalAdd].votecount2;
    }
    
    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){
        bytes memory _ba = bytes(_a);
        bytes memory _bb = bytes(_b);
        bytes memory _bc = bytes(_c);
        bytes memory _bd = bytes(_d);
        bytes memory _be = bytes(_e);
        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);
        bytes memory babcde = bytes(abcde);
        uint k = 0;
        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
        return string(babcde);
    }

    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {
        return strConcat(_a, _b, _c, _d, "");
    }

    function strConcat(string _a, string _b, string _c) internal returns (string) {
        return strConcat(_a, _b, _c, "", "");
    }

    function strConcat(string _a, string _b) internal returns (string) {
        return strConcat(_a, _b, "", "", "");
    }
}